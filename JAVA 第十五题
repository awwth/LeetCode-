1、在字符串不经常发生变化的业务场景优先使用String(代码更清晰简洁)。如常量的声明，少量的字符串操作(拼接，删除等)。

2、在单线程情况下，如有大量的字符串操作情况，应该使用StringBuilder来操作字符串。不能使用String"+"来拼接而是使用，避免产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。如JSON的封装等。

3、在多线程情况下，如有大量的字符串操作情况，应该使用StringBuffer。如HTTP参数解析和封装等。

报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221

1 被读作  "one 1"  ("一个一") , 即 11。
11 被读作 "two 1s" ("两个一"）, 即 21。
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。

注意：整数顺序将表示为一个字符串。

 

示例 1:

输入: 1
输出: "1"

示例 2:

输入: 4
输出: "1211"

2 ---  11
3 ---  21
4 ---  1211
5 ---  111221
6 ---  312211
7 ---  13112221
1 1（固定的）
2 对上面1的说明：即一个一11
3 对上面11的说明：即两个1 21
4 对上面121的说明：即一个1一个2一个1：1211
5 对上面1211的说明：一个1一个2，两个1（两个1是连续的，因此就是两个1）111221
6 对上面111221是说明：三个1，两个2，一个1 即 312211
…以此类推

class Solution 
{ public: 
 string countAndSay(int n) 
 { if(n==1) return "1"; 
  string strlast=countAndSay(n-1); 
  int count = 1; 
  string res; 
  for(int i=0;i<strlast.size();i++)
  {
      if(strlast[i]==strlast[i+1])
        { count++; continue; }
            else {
                if(strlast[i]!=strlast[i+1]) 
                { res+=to_string(count)+strlast[i]; count=1; } 
                 } 
  } return res; 
 } 
};

